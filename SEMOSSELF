#!/usr/bin/env python3
from ev3dev.ev3 import *
from time import sleep

#MOTORES

motor_esquerdo = LargeMotor("outA")
motor_direito = LargeMotor("")

#SENSORES

girosen = GyroSensor("in1")
colorsen_dir = ColorSensor("in2")
colorsen_esq = ColorSensor("in3")
infrasen = InfraredSensor("in4")

#MODOS DOS SENSOR

girosen.mode = "GYRO-ANG"
colorsen_esq.mode = "COL-COLOR"
colorsen_dir.mode = "COL-COLOR"
infrasen.mode = "IR-PROX"

#GLOBAIS

CAMINHO = {}
VELOCIDADE_NORMAL = 300
ANGULO_INICIAL = girosen.value()
ANGULO_RELATIVO = girosen.value()
VARIACAO_DE_VEL_GIRO = 100
ERRO_ANG = 0
CORATUAL = 8
VELO_PRECISA_FRENTE = 70
VELO_PRECISA_TRAS = -70

#CORES

NADA = 0
PRETO = 1
AZUL = 2
VERDE = 3
VERMELHO = 5
BRANCO = 6

#VARIAVEIS LOCAIS PARA O INFRARED

RE_DE_CORRECAO1 = -130
RE_DE_CORRECAO2 = -100
VELO_RELATIVOS = 400

#VARIAVEIS LOCAIS PARA GIROSCOPIO

ERRO_MINIMO = -5
ERRO_MAXIMO = 6
MEIA_VOLTA = 173
ANGULO_DIREITA = 80
ANGULO_ESQUERDA = -80


def andar():

    """

        Essa função tem o intuito de ordenar e controlar o robô, apartir dos dados recebidos dos sensores, ela altera
        o valor da variavel "ANGULO_RELATIVO" que baseada na variável "ANGULO_INICIAL" (o angulo de inicio do percurso
        atual) combinada com a variação do valor indicado pelo infra vermelho, fazendo com que o robô "curve" o angulo
        de sua direção e corriga sua posição. OBS: Só funciona quando está no branco.

    """

    while colorsen_dir.value() == BRANCO or colorsen_esq.value() == BRANCO:  # sensores detectando a cor branca
        global ANGULO_RELATIVO
        global ERRO_ANG

        print("Cor atual: %d\nCor esquerda: %d\nCor direita: %d\nangulo ini: %d\ngiro: %d\n\n\n" % (
        CORATUAL, colorsen_esq.value(), colorsen_dir.value(), ANGULO_RELATIVO, girosen.value()))

        # Correção de infrared
        ANGULO_RELATIVO = ANGULO_INICIAL - (infrasen.value() - 17)

        ERRO_ANG = ANGULO_RELATIVO - girosen.value()

        if colorsen_esq.value() == NADA or colorsen_dir.value() == NADA:# SAINDO DA PISTA
            if colorsen_dir.value() == NADA:
                motor_direito.run_to_rel_pos(position_sp=RE_DE_CORRECAO1, speed_sp=VELO_RELATIVOS)
                motor_esquerdo.run_to_rel_pos(position_sp=RE_DE_CORRECAO1, speed_sp=VELO_RELATIVOS)
                motor_direito.wait_while("running")
                motor_esquerdo.wait_while("running")
                motor_direito.stop()
                motor_esquerdo.run_to_rel_pos(position_sp=RE_DE_CORRECAO2, speed_sp=VELO_RELATIVOS)
                motor_esquerdo.wait_while("running")
            else:
                motor_direito.run_to_rel_pos(position_sp=RE_DE_CORRECAO1, speed_sp=VELO_RELATIVOS)
                motor_esquerdo.run_to_rel_pos(position_sp=RE_DE_CORRECAO1, speed_sp=VELO_RELATIVOS)
                motor_direito.wait_while("running")
                motor_esquerdo.wait_while("running")
                motor_esquerdo.stop()
                motor_direito.run_to_rel_pos(position_sp=RE_DE_CORRECAO2, speed_sp=VELO_RELATIVOS)
                motor_direito.wait_while("running")

        elif ERRO_ANG in range(ERRO_MINIMO, ERRO_MAXIMO):
            if girosen.value() < ANGULO_RELATIVO:  # esquerda
                motor_esquerdo.run_forever(speed_sp=VELOCIDADE_NORMAL + (ERRO_ANG * VARIACAO_DE_VEL_GIRO))
                sleep(0.53)

            elif girosen.value() > ANGULO_RELATIVO:  # direita
                motor_direito.run_forever(speed_sp=VELOCIDADE_NORMAL + (ERRO_ANG * VARIACAO_DE_VEL_GIRO))
                sleep(0.53)

        elif ERRO_ANG < ERRO_MINIMO or ERRO_ANG > ERRO_MAXIMO:
            motor_direito.stop()
            motor_esquerdo.stop()
            if girosen.value() > ANGULO_RELATIVO:
                while girosen.value() > ANGULO_RELATIVO:
                    motor_direito.run_forever(speed_sp=VELO_PRECISA_FRENTE)
                    motor_esquerdo.run_forever(speed_sp=VELO_PRECISA_TRAS)
            else:
                while girosen.value() < ANGULO_RELATIVO:
                    motor_esquerdo.run_forever(speed_sp=VELO_PRECISA_FRENTE)
                    motor_direito.run_forever(speed_sp=VELO_PRECISA_TRAS)

        motor_esquerdo.run_forever(speed_sp=300)
        motor_direito.run_forever(speed_sp=300)


def meiavolta():
    global ERRO_ANG
    global ANGULO_INICIAL

    ERRO_ANG = ANGULO_RELATIVO - girosen.value()

    if ERRO_ANG > 0:
        angulo = girosen.value()
        ang_rel = angulo + (MEIA_VOLTA + ERRO_ANG)
    elif ERRO_ANG < 0:
        angulo = girosen.value()
        ang_rel = angulo + (MEIA_VOLTA - ERRO_ANG)
    else:
        angulo = girosen.value()
        ang_rel = angulo + MEIA_VOLTA

    angulo = girosen.value()  # angulo_inicial
    while colorsen_dir.value() != colorsen_esq.value():
        if colorsen_esq.value() != PRETO and colorsen_dir.value() == PRETO:
            while colorsen_esq != PRETO:
                motor_esquerdo.run_forever(speed_sp=VELO_PRECISA_FRENTE)
        elif colorsen_dir.value() != PRETO and colorsen_esq.value() == PRETO:
            while colorsen_dir != PRETO:
                motor_direito.run_forever(speed_sp=VELO_PRECISA_FRENTE)

    while angulo < ang_rel:
        angulo = girosen.value()
        motor_esquerdo.run_forever(speed_sp=curva_frente)
        motor_direito.run_forever(speed_sp=curva_tras)

    ANGULO_INICIAL = ang_rel


def curvaD(self):
    global ANGULO_INICIAL

    curva_frente = 400
    curva_tras = -400

    # Angulação da curva
    ERRO_ANG = ANGULO_RELATIVO - girosen.value()
    if ERRO_ANG > 0:
        angulod = girosen.value()
        ang_reld = angulod + (ANGULO_DIREITA + ERRO_ANG)
    elif ERRO_ANG < 0:
        angulod = girosen.value()
        ang_reld = angulod + (ANGULO_DIREITA - ERRO_ANG)
    else:
        angulod = girosen.value()
        ang_reld = angulod + MEIA_VOLTA

    self.motor_D.stop()
    self.motor_E.stop()
    # Correção na entrada da cor

    self.motor_D.stop()
    self.motor_E.stop()
    while colorsen_dir.value() == CORATUAL and colorsen_esq.value() == CORATUAL:
        self.motor_E.run_forever(speed_sp=VELOCIDADE_NORMAL)
        self.motor_D.run_forever(speed_sp=VELOCIDADE_NORMAL)
    self.motor_D.run_to_rel_pos(position_sp=RE_DE_CORRECAO1, speed_sp=VELO_RELATIVOS)
    self.motor_E.run_to_rel_pos(position_sp=RE_DE_CORRECAO1, speed_sp=VELO_RELATIVOS)
    self.motor_D.wait_while("running")
    self.motor_E.wait_while("running")

    while angulod < ang_reld:
        angulod = self.giroS.value()
        self.motor_E.run_forever(speed_sp=curva_frente)
        self.motor_D.run_forever(speed_sp=curva_tras)

    while colorsen_dir.value() == CORATUAL and colorsen_esq.value() == CORATUAL:
        self.motor_E.run_forever(speed_sp=VELOCIDADE_NORMAL)
        self.motor_D.run_forever(speed_sp=VELOCIDADE_NORMAL)

    self.angulo_in += ANGULO_DIREITA


def curvaE(self):
    # Angulação da curva
    self.erro_ang = self.angulo_rel - self.giroS.value()
    if self.erro_ang > 0:
        angulo = self.giroS.value()
        ang_reld = angulo - (80 + self.erro_ang)
    elif self.erro_ang < 0:
        angulo = self.giroS.value()
        ang_reld = angulo - (80 - self.erro_ang)
    else:
        angulo = self.giroS.value()
        ang_reld = angulo - 80

    motor_direito.stop()
    motor_esquerdo.stop()
    # Correção na entrada da cor
    erro_ang = angulo_rel - self.giroS.value()
    if erro_ang > 0:
        while erro_ang not in range(-1, 2):
            motor_esquerdo.run_forever(speed_sp=-50)
            motor_direito.run_forever(speed_sp=50)
    elif erro_ang < 0:
        while erro_ang not in range(-1, 2):
            motor_esquerdo.run_forever(speed_sp=50)
            motor_direito.run_forever(speed_sp=-50)

    motor_direito.stop()
    motor_esquerdo.stop()

    while colorsen_dir.value() == coratual and colorsen_esq.value() == coratual:
        motor_esquerdo.run_forever(speed_sp=200)
        motor_direito.run_forever(speed_sp=200)
    motor_direito.run_to_rel_pos(position_sp=-130, speed_sp=400)
    motor_esquerdo.run_to_rel_pos(position_sp=-130, speed_sp=400)
    motor_direito.wait_while("running")
    motor_esquerdo.wait_while("running")

    while angulo > ang_reld:
        angulod = giroS.value()
        motor_esquerdo.run_forever(speed_sp=-400)
        motor_direito.run_forever(speed_sp=400)

    while colorsen_dir.value() == coratual and colorsen_esq.value() == coratual:
        motor_esquerdo.run_forever(speed_sp=200)
        motor_direito.run_forever(speed_sp=200)

    angulo_in -= 80


def main(self):
    # Sound.beep()
    lista_anda = [0, 6, 1]
    while True:
        print("Cor atual: %d\nCor esquerda: %d\nCor direita: %d\nangulo ini: %d\ngiro: %d\n\n\n" % (
        coratual, colorESQ.value(), colorDIR.value(), angulo_rel, giroS.value()))
        if colorsen_dir.value() == 6 and colorsen_esq.value() == 6:
            Sound.tone(70, 500)
            andar()
        elif colorsen_esq.value() not in lista_anda and colorsen_dir.value() not in lista_anda:
            coratual = colorsen_dir.value()
            if coratual in caminho.keys():
                g = caminho.items()
            else:
                while colorsen_dir.value() == coratual and colorsen_esq.value() == coratual:
                    motor_esquerdo.run_forever(speed_sp=200)
                    motor_direito.run_forever(speed_sp=200)

                if colorsen_dir.value() == coratual and colorsen_esq.value() != coratual:
                    while colorsen_esq.value() != coratual:
                        motor_esquerdo.run_forever(speed_sp=-50)
                        motor_direito.run_forever(speed_sp=-50)

                    while angulo_in < giroS.value():
                        motor_esquerdo.run_forever(speed_sp=-50)
                        motor_direito.run_forever(speed_sp=50)

                elif colorsen_dir.value() != coratual and colorsen_esq.value() == coratual:
                    while colorsen_dir.value() != coratual:
                        motor_esquerdo.run_forever(speed_sp=-50)
                        motor_direito.run_forever(speed_sp=-50)
                    while giroS.value() < angulo_in:
                        motor_esquerdo.run_forever(speed_sp=50)
                        motor_direito.run_forever(speed_sp=-50)

                motor_esquerdo.run_forever(speed_sp=200)
                motor_direito.run_forever(speed_sp=200)
                sleep(1)

                andar()
                print("oi")
                motor_direito.stop()
                motor_esquerdo.stop()

                if colorsen_esq.value() == 1 and colorsen_dir.value() == 1:
                    meiavolta()
                    andar()
                    curvaD()
                    andar()
                    if colorsen_dir.value() != 1 and colorESQ.value() != 1:
                        caminho[coratual] = "L"
                        print(caminho.items())
                        main()
                    else:
                        caminho[coratual] = "R"
                        print(caminho.items())
                        meiavolta()
                        andar()
                        while colorESQ.value() == coratual or colorDIR.value() == coratual:
                            motor_direito.run_forever(speed_sp=300)
                            motor_esquerdo.run_forever(speed_sp=300)
                        self.main()
                elif (colorDIR.value() not in lista_anda) and (colorESQ.value() not in lista_anda):
                    caminho[coratual] = "F"
                    print(caminho.items())
                    main()


# colors = ["nda","preto","azul","verde","amarelo","vermelho","branco","marrom"]
